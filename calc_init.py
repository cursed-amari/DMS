# Form implementation generated from reading ui file 'calc_init.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtWidgets
from PyQt6.QtWidgets import QMessageBox
from loguru import logger
from calc_init_class import Ui_MainWindow_init
import json
import random


enemy_list = []
initiative_list = []
enemy_dict_preset = {}

logger.add("debug_init.log", format="{time}, {level}, {message}", level="DEBUG", rotation="5 MB", compression="zip")

try:
    class InitiativeWindow(QtWidgets.QMainWindow, Ui_MainWindow_init):
        def __init__(self, hero):
            super().__init__()
            self.setupUi(self)
            self.hero = hero
            self.app_func()


        def app_func(self):
            self.pushButton_initiative.clicked.connect(self.calk_initiative)
            self.pushButton_add.clicked.connect(self.check_input)
            self.pushButton_add.clicked.connect(self.enemy_box_update)
            self.pushButton_clean_enemy.clicked.connect(self.clean_enemy)
            self.set_preset.clicked.connect(self.preset_update)
            self.load_preset.clicked.connect(self.preset_load)
            self.del_preset.clicked.connect(self.preset_delete)
            self.radioButton.toggled.connect(self.show_n_hide_options)

            self.box_select_character.currentTextChanged.connect(self.selected_enemy_view)
            self.pushButton_set_redaction.clicked.connect(self.redaction_enemy)
            self.del_character.clicked.connect(self.del_enemy)
            self.pushButton_apply_player_dice.clicked.connect(self.view_player_initiative)

            logger.info("app_func")
            self.view_player_initiative()
            self.view_enemy()
            self.preset_combo_box_update()

        '''
        Main
        '''

        def check_input(self):
            try:
                initiative = int(self.enemy_initiative_edit.text())
                self.add_enemy()
                logger.info("check_input")
            except:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Не корректный ввод инициативы')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("check_input. except")

        def show_n_hide_options(self):
            check_options = self.radioButton.isChecked()

            if check_options:
                self.centralwidget.setFixedSize(500, 425)
                self.view_enemy()
                self.enemy_box_update()
                self.selected_enemy_view()
            else:
                self.centralwidget.setFixedSize(310, 425)
            logger.info("show_n_hide_options")

        def add_enemy(self):
            global enemy_list
            value = ''
            in_enemy_list = False
            name = self.enemy_name_edit.text()
            initiative = int(self.enemy_initiative_edit.text())
            if name == '':
                if not enemy_list:
                    name = 'Enemy_0'
                else:
                    for i in range(len(enemy_list)):
                        name = 'Enemy_' + str(i+1)
            for item in range(len(enemy_list)):
                if name in enemy_list[item]:
                    in_enemy_list = True
            if in_enemy_list == True:
                name += '_' + str(item)
            enemy_list += [initiative, name],
            logger.info("add_enemy")
            self.view_enemy()


        def view_enemy(self):
            value = ''
            for i in range(len(enemy_list)):
                value += f'{enemy_list[i][1]}' + ' ' + f'{enemy_list[i][0]}' + '\n'
            self.label_enemy.setText(value)
            logger.info("view_enemy")

        def clean_enemy(self):
            global enemy_list
            enemy_list = []
            self.label_enemy.setText('')
            logger.info("clean_enemy")
            self.enemy_box_update()
            self.selected_enemy_view()

        def view_player_initiative(self):
            if "character0" in self.hero.keys():
                self.set_player_dice_edit_char_0.setText(str(int(self.hero["character0"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_0 = self.hero["character0"]["initiative"]
            if "character1" in self.hero.keys():
                self.set_player_dice_edit_char_1.setText(str(int(self.hero["character1"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_1 = self.hero["character1"]["initiative"]
            if "character2" in self.hero.keys():
                self.set_player_dice_edit_char_2.setText(str(int(self.hero["character2"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_2 = self.hero["character2"]["initiative"]
            if "character3" in self.hero.keys():
                self.set_player_dice_edit_char_3.setText(str(int(self.hero["character3"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_3 = self.hero["character3"]["initiative"]
            logger.info("view_player_initiative")

        def calk_initiative(self):
            '''
            DOCKSTRING: подсчёт инициативы
            '''
            global initiative_list
            initiative_list = []


            for i in range(len(self.hero)):
                if i == 0:
                    t = int(self.set_player_dice_edit_char_0.text())
                if i == 1:
                    t = int(self.set_player_dice_edit_char_1.text())
                if i == 2:
                    t = int(self.set_player_dice_edit_char_2.text())
                if i == 3:
                    t = int(self.set_player_dice_edit_char_3.text())
                n = self.hero['character' + str(i)]['name']
                initiative_list += [t, n],

            for i in range(len(enemy_list)):
                init = int(enemy_list[i][0]) + random.randint(1, 20)
                n = enemy_list[i][1]
                initiative_list += [init, n],

            initiative_list.sort(key=lambda x: (x[0], x[1]), reverse=True)

            logger.info("calk_initiative")
            self.calk_initiative_view()
        def calk_initiative_view(self):
            value = ''
            for i in range(len(initiative_list)):
                value += f'{initiative_list[i][1]}' + ' ' + f'{initiative_list[i][0]}' + '\n'
            self.label_calk_enemy.setText(value)
            logger.info("calk_initiative_view")

        def preset_update(self):
            '''
            DOCKSTRING: Добавление ссылок на музыку в словарь в формате сцена: урл
            '''
            global enemy_dict_preset
            if self.preset_edit.text() not in enemy_dict_preset.keys():
                enemy_dict_preset[self.preset_edit.text()] = enemy_list.copy()
                logger.info(f"preset_update, {enemy_dict_preset}")
                self.preset_combo_box_update()
                self.preset_edit.setText('')
            else:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Такой пресет уже создан')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("preset_update")


        def preset_combo_box_update(self):
            '''
            DOCKSTRING: обновление комбо бокса, при загрузке сохранения
            '''
            self.comboBox_preset.clear()
            for i in enemy_dict_preset.keys():
                self.comboBox_preset.addItem(i)
            logger.info("preset_combo_box_update")

        def preset_load(self):
            try:
                enemy_list.clear()
                print(enemy_dict_preset)
                for i in list(enemy_dict_preset[self.comboBox_preset.currentText()]):
                    enemy_list.append(i)
                logger.info("preset_load")
                self.view_enemy()
                self.enemy_box_update()
                self.selected_enemy_view()

            except NameError:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Противник не найден')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("preset_load, except NameError")

        def preset_delete(self):
            if self.comboBox_preset.currentText() in enemy_dict_preset.keys():
                list_key = list(enemy_dict_preset.keys())
                enemy_dict_preset.pop(self.comboBox_preset.currentText())
                self.comboBox_preset.removeItem(list_key.index(self.comboBox_preset.currentText()))
                logger.info("preset_delete")
            else:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Сцена не найдена')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("preset_delete. except")

        '''
        Options
        '''

        def enemy_box_update(self):
            self.box_select_character.clear()
            self.comboBox_del_char.clear()
            for i in enemy_list:
                self.box_select_character.addItem(i[1])
                self.comboBox_del_char.addItem(i[1])
            logger.info("enemy_box_update")

        def selected_enemy_view(self):
            for i in enemy_list:
                if i[1] == self.box_select_character.currentText():
                    self.edit_name_redaction.setText(i[1])
                    self.edit_initiative_redaction.setText(str(i[0]))
            logger.info("selected_enemy_view")

        def redaction_enemy(self):
            for i in enemy_list:
                if i[1] == self.box_select_character.currentText():
                    i[0] = int(self.edit_initiative_redaction.text())
                    i[1] = self.edit_name_redaction.text()
            logger.info(f"redaction_enemy, {enemy_list}")
            self.enemy_box_update()
            self.selected_enemy_view()
            self.view_enemy()

        def del_enemy(self):
            try:
                for i in range(len(enemy_list)):
                    if enemy_list[i][1] == self.comboBox_del_char.currentText():
                        del_num = i
                enemy_list.pop(del_num)
                for i in range(len(initiative_list)):
                    if initiative_list[i][1] == self.comboBox_del_char.currentText():
                        del_init_enemy = i
                initiative_list.pop(del_init_enemy)
                logger.info("del_enemy")
                self.calk_initiative_view()
            except NameError:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Противник не найден')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("del_enemy. except NameError")


            self.enemy_box_update()
            self.selected_enemy_view()
            self.view_enemy()



        def popup_action(self, but):
            if but.text() == 'Ok':
                print('Ошибка ввода')
            pass
finally:
    with open("data_enemy", "w", encoding="utf-8") as file:
        json.dump(enemy_dict_preset, file)



