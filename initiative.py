# Form implementation generated from reading ui file 'calc_init.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtWidgets
from PyQt6.QtWidgets import QMessageBox
from loguru import logger
from initiative_class import Ui_MainWindow_init
import json
import random


enemy_list = []
initiative_list = []
enemy_dict_preset = {}

try:
    class InitiativeWindow(QtWidgets.QMainWindow, Ui_MainWindow_init):
        def __init__(self, hero, dict_preset):
            global enemy_dict_preset
            super().__init__()
            self.setupUi(self)
            enemy_dict_preset = dict_preset
            self.hero = hero
            self.app_func()
            logger.info("start initiative")

        @logger.catch
        def app_func(self):
            self.pushButton_initiative.clicked.connect(self.calk_initiative)
            self.pushButton_add.clicked.connect(self.check_input)
            self.pushButton_add.clicked.connect(self.enemy_box_update)
            self.pushButton_clean_enemy.clicked.connect(self.clean_enemy)
            self.set_preset.clicked.connect(self.preset_update)
            self.load_preset.clicked.connect(self.preset_load)
            self.del_preset.clicked.connect(self.preset_delete)

            self.box_select_character.currentTextChanged.connect(self.selected_enemy_view)
            self.pushButton_set_redaction.clicked.connect(self.redaction_enemy)
            self.del_character.clicked.connect(self.del_enemy)
            self.pushButton_apply_player_dice.clicked.connect(self.view_player_initiative)

            self.view_player_initiative()
            self.view_enemy()
            self.preset_combo_box_update()

        '''
        Main
        '''

        @logger.catch
        def check_input(self, bool_val):
            try:
                initiative = int(self.enemy_initiative_edit.text())
                self.add_enemy()
            except:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Не корректный ввод инициативы')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("check_input. except")

        @logger.catch
        def add_enemy(self):
            global enemy_list
            value = ''
            in_enemy_list = False
            name = self.enemy_name_edit.text()
            initiative = int(self.enemy_initiative_edit.text())
            hp = int(self.enemy_hp_edit.text())
            if name == '':
                if not enemy_list:
                    name = 'Enemy_0'
                else:
                    for i in enumerate(enemy_list):
                        name = 'Enemy_' + str(i[0]+1)
            for item in enumerate(enemy_list):
                if name in enemy_list[item[0]]:
                    in_enemy_list = True
            if in_enemy_list == True:
                name += '_' + str(item[0])
            enemy_list += [initiative, name, hp],
            self.view_enemy()


        @logger.catch
        def view_enemy(self):
            value = ''
            for i in enumerate(enemy_list):
                value += f'{enemy_list[i[0]][2]}' + ' ' + f'{enemy_list[i[0]][1]}' + ' ' + f'{enemy_list[i[0]][0]}' + '\n'
            self.label_enemy.setText(value)

        @logger.catch
        def clean_enemy(self, bool_val):
            global enemy_list
            enemy_list = []
            self.label_enemy.setText('')
            self.enemy_box_update()
            self.selected_enemy_view()

        @logger.catch
        def view_player_initiative(self, bool_val=False):
            if "character0" in self.hero.keys():
                self.set_player_dice_edit_char_0.setText(str(int(self.hero["character0"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_0 = self.hero["character0"]["initiative"]
            if "character1" in self.hero.keys():
                self.set_player_dice_edit_char_1.setText(str(int(self.hero["character1"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_1 = self.hero["character1"]["initiative"]
            if "character2" in self.hero.keys():
                self.set_player_dice_edit_char_2.setText(str(int(self.hero["character2"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_2 = self.hero["character2"]["initiative"]
            if "character3" in self.hero.keys():
                self.set_player_dice_edit_char_3.setText(str(int(self.hero["character3"]["initiative"]) + random.randint(1, 20)))
                self.initiative_chr_3 = self.hero["character3"]["initiative"]

        @logger.catch
        def calk_initiative(self, bool_val):
            '''
            DOCKSTRING: подсчёт инициативы
            '''
            global initiative_list
            initiative_list = []
            self.hero_list = []


            for i in enumerate(self.hero):
                if i[0] == 0:
                    t = int(self.set_player_dice_edit_char_0.text())
                if i[0] == 1:
                    t = int(self.set_player_dice_edit_char_1.text())
                if i[0] == 2:
                    t = int(self.set_player_dice_edit_char_2.text())
                if i[0] == 3:
                    t = int(self.set_player_dice_edit_char_3.text())
                n = self.hero['character' + str(i[0])]['name']
                initiative_list += [t, n],
                self.hero_list.append(n)

            for i in enumerate(enemy_list):
                init = int(enemy_list[i[0]][0]) + random.randint(1, 20)
                n = enemy_list[i[0]][1]
                hp = enemy_list[i[0]][2]
                initiative_list += [init, n, hp],

            initiative_list.sort(key=lambda x: (x[0], x[1]), reverse=True)

            self.calk_initiative_view()

        @logger.catch
        def calk_initiative_view(self):
            value = ''
            for i in enumerate(initiative_list):
                if initiative_list[i[0]][1] in self.hero_list:
                    value += f'{initiative_list[i[0]][1]}' + ' ' + f'{initiative_list[i[0]][0]}' + '\n'
                else:
                    value += f'{initiative_list[i[0]][2]}' + ' ' + f'{initiative_list[i[0]][1]}' + ' ' + f'{initiative_list[i[0]][0]}' + '\n'
            self.label_calk_enemy.setText(value)
            self.save_enemy_preset()

        @logger.catch
        def preset_update(self, bool_val):
            '''
            DOCKSTRING: Добавление противников в словарь в формате сцена: [противник, ]
            '''
            global enemy_dict_preset
            if self.preset_edit.text() not in enemy_dict_preset.keys():
                enemy_dict_preset[self.preset_edit.text()] = enemy_list.copy()
                self.preset_combo_box_update()
                self.save_enemy_preset()
                self.preset_edit.setText('')
            else:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Такой пресет уже создан')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()

        @logger.catch
        def save_enemy_preset(self):
            with open("data_enemy", "w", encoding="utf-8") as file:
                json.dump(enemy_dict_preset, file)

        @logger.catch
        def preset_combo_box_update(self):
            '''
            DOCKSTRING: обновление комбо бокса, при загрузке сохранения
            '''
            self.comboBox_preset.clear()
            for i in enemy_dict_preset.keys():
                self.comboBox_preset.addItem(i)

        @logger.catch
        def preset_load(self, bool_val):
            try:
                enemy_list.clear()
                for i in list(enemy_dict_preset[self.comboBox_preset.currentText()]):
                    enemy_list.append(i)
                self.view_enemy()
                self.enemy_box_update()
                self.selected_enemy_view()

            except NameError:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Противник не найден')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("preset_load, except NameError")

        @logger.catch
        def preset_delete(self, bool_val):
            if self.comboBox_preset.currentText() in enemy_dict_preset.keys():
                list_key = list(enemy_dict_preset.keys())
                enemy_dict_preset.pop(self.comboBox_preset.currentText())
                self.comboBox_preset.removeItem(list_key.index(self.comboBox_preset.currentText()))
                self.save_enemy_preset()
            else:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Сцена не найдена')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()

        @logger.catch
        def enemy_box_update(self, bool_val=False):
            self.box_select_character.clear()
            self.comboBox_del_char.clear()
            for i in enemy_list:
                self.box_select_character.addItem(i[1])
                self.comboBox_del_char.addItem(i[1])

        @logger.catch
        def selected_enemy_view(self, enemy_name=0):
            for i in enemy_list:
                if i[1] == self.box_select_character.currentText():
                    self.edit_name_redaction.setText(i[1])
                    self.edit_initiative_redaction.setText(str(i[0]))
                    self.edit_hp_redaction.setText((str(i[2])))

        @logger.catch
        def redaction_enemy(self, bool_val):
            for i in enemy_list:
                if i[1] == self.box_select_character.currentText():
                    i[0] = int(self.edit_initiative_redaction.text())
                    i[1] = self.edit_name_redaction.text()
                    i[2] = self.edit_hp_redaction.text()
            self.selected_enemy_view()
            self.view_enemy()
            self.redaction_enemy_view()

        def redaction_enemy_view(self):
            global initiative_list
            for i in initiative_list:
                if i[1] == self.box_select_character.currentText():
                    i[0] = int(self.edit_initiative_redaction.text())
                    i[1] = self.edit_name_redaction.text()
                    i[2] = self.edit_hp_redaction.text()
            self.calk_initiative_view()
            self.enemy_box_update()

        @logger.catch
        def del_enemy(self, bool_val):
            try:
                for i in enumerate(enemy_list):
                    if enemy_list[i[0]][1] == self.comboBox_del_char.currentText():
                        del_num = i[0]
                enemy_list.pop(del_num)
                for enemy in initiative_list:
                    if self.comboBox_del_char.currentText() in enemy[1]:
                        for i in enumerate(initiative_list):
                            if initiative_list[i[0]][1] == self.comboBox_del_char.currentText():
                                del_init_enemy = i[0]
                        initiative_list.pop(del_init_enemy)
                self.calk_initiative_view()
            except NameError:
                error = QMessageBox()
                error.setWindowTitle('Ошибка')
                error.setText('Противник не найден')
                error.setIcon(QMessageBox.Icon.Warning)
                error.setStandardButtons(QMessageBox.StandardButton.Ok)
                error.setDefaultButton(QMessageBox.StandardButton.Ok)

                error.buttonClicked.connect(self.popup_action)

                error.exec()
                logger.info("del_enemy. except NameError")


            self.enemy_box_update()
            self.selected_enemy_view()
            self.view_enemy()
            self.save_enemy_preset()

        @logger.catch
        def popup_action(self, but):
            if but.text() == 'Ok':
                logger.info("popup_action")
            pass
finally:
    logger.info("calc_init read")
