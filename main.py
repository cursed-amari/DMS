# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
from PyQt6 import QtWidgets, QtCore, QtGui
from PyQt6.QtGui import QPixmap
from PyQt6.QtWidgets import QFileDialog, QMessageBox, QInputDialog, QMenu, QGraphicsScene, QApplication, \
    QGraphicsPixmapItem
from PyQt6.QtCore import Qt, pyqtSignal, QPoint
import pygame
from loguru import logger
import re
import webbrowser
import time
import json
import os
import fnmatch
import requests
from mutagen.mp3 import MP3
from mutagen.wavpack import WavPack
from mutagen.oggvorbis import OggVorbis

from initializing_windows.img_viewer_new_token import Ui_Dialog_new_token
from initializing_windows.main_class import Ui_MainWindow
from initiative import InitiativeWindow
from music_timer import MusicTimer

from too_many_generators import MainWindow_too_many_generators
from img_view import Window_viewer_show
from token_img import TokenImg, InitiativeImg
from hero_class import Hero

from utils import *

hero = {}
music = {}
store = {}
npc = {}
scenario_chapter = {}
scenario = []
scenario_text = {}
dict_preset = {}
note_zero = ""
note_one = ""
note_two = ""
note_three = ""

pygame.init()

logger.add("debug.log", format="{time}, {level}, {message}", level="DEBUG", rotation="2 days", retention="2 days")
try:
    class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
        def __init__(self):
            super().__init__()
            self.setupUi(self)

            self.status = 0
            logger.info("Start")
            self.scale_img_viewer = 0
            self.slide_menu_num = 0
            self.scale_img_view = 0.25
            self.token_list = {}
            self.scene_items = {}
            self.music_timer = MusicTimer()

            self.aplication_func()

        @logger.catch
        def aplication_func(self):
            # initializing
            self.viewer_window = Window_viewer_show()
            self.viewer_window_master = Window_viewer_show()
            self.initiative_window = InitiativeWindow(hero, dict_preset)
            self.mixer = pygame.mixer.music

            # Menu
            self.toolButton_logo_app.clicked.connect(self.main_menu)
            self.toolButton_menu.clicked.connect(self.slide_menu)
            self.toolButton_tracker.clicked.connect(self.show_frame_menu)
            self.toolButton_scenario.clicked.connect(self.show_frame_menu)
            self.toolButton_notes.clicked.connect(self.show_frame_menu)
            self.toolButton_music_changer.clicked.connect(self.show_frame_menu)
            self.toolButton_rules.clicked.connect(self.show_frame_menu)
            self.toolButton_generate_store.clicked.connect(self.show_frame_menu)
            self.toolButton_npc_generator.clicked.connect(self.show_frame_menu)
            self.toolButton_img_view.clicked.connect(self.show_frame_menu)

            self.frame_tracker.mousePressEvent = self.slide_menu_hide
            self.frame_scenario.mousePressEvent = self.slide_menu_hide
            self.frame_notes.mousePressEvent = self.slide_menu_hide
            self.frame_music_changer.mousePressEvent = self.slide_menu_hide
            self.frame_rules.mousePressEvent = self.slide_menu_hide
            self.label_rules.mousePressEvent = self.slide_menu_hide
            self.frame_viewer_navigations.mousePressEvent = self.slide_menu_hide
            self.frame_list.mousePressEvent = self.slide_menu_hide
            self.frame_viewer.mousePressEvent = self.slide_menu_hide
            self.frame_generate_store.mousePressEvent = self.slide_menu_hide
            self.label_shop_info.mousePressEvent = self.slide_menu_hide
            self.text_assortment_shop.mousePressEvent = self.slide_menu_hide
            self.frame_npc_generator.mousePressEvent = self.slide_menu_hide
            self.label_generate_npc.mousePressEvent = self.slide_menu_hide

            # PUSHBUTTON
            self.pushButton_exit.clicked.connect(self.close_all_window)
            self.pushButton_minimized.clicked.connect(self.showMinimized)
            # tracker
            self.pushButton.clicked.connect(self.input_chek)
            self.pushButton_init_open.clicked.connect(self.open_initiative)
            self.pushButton_roll_dice.clicked.connect(self.roll_dice)
            self.pushButton_del_char.clicked.connect(self.del_char)
            # scenario
            self.pushButton_add_tags.clicked.connect(self.status_list_tags)
            self.pushButton_add_chapter.clicked.connect(self.add_chapter)
            self.pushButton_del_tags.clicked.connect(self.del_object_scenario)
            self.pushButton_del_chapter.clicked.connect(self.del_chapter)
            # music
            self.pushButton_url_set.clicked.connect(self.music_changer_update)
            self.pushButton_url_open.clicked.connect(self.music_changer_play)
            self.pushButton_url_delete.clicked.connect(self.music_changer_delete)
            self.pushButton_music_play.clicked.connect(self.play_local_music)
            self.pushButton_music_pause.clicked.connect(self.pause_local_music)
            self.pushButton_music_stop.clicked.connect(self.stop_local_music)
            self.music_timer.signal.connect(self.update_slider_position)
            self.horizontalSlider_music.sliderMoved.connect(self.set_track_position)
            # viewer
            self.pushButton_open_view.clicked.connect(self.open_viewer_window)
            self.pushButton_left.clicked.connect(self.left_img)
            self.pushButton_right.clicked.connect(self.right_img)
            self.pushButton_refresh_img.clicked.connect(self.collect_img)
            self.pushButton_reduce_token.clicked.connect(self.reduce_token)
            self.pushButton_increase_token.clicked.connect(self.increase_token)
            # self.pushButton_reduce_img.clicked.connect(self.reduce_img)
            # self.pushButton_increase_img.clicked.connect(self.increase_img)
            self.pushButton_add_enemy_token.clicked.connect(self.add_enemy_token)
            self.pushButton_add_hero_token.clicked.connect(self.add_hero_token)
            self.pushButton_add_unknown_token.clicked.connect(self.add_unknown_token)
            self.pushButton_add_initiative.clicked.connect(self.add_initiative)
            # generate store
            self.pushButton_generate_shop.clicked.connect(self.create_store)
            self.pushButton_del_store.clicked.connect(self.del_store)
            # generate npc
            self.pushButton_generate_npc.clicked.connect(self.create_npc)
            self.pushButton_del_npc.clicked.connect(self.del_npc)

            # CHECKBOX
            # tracker

            # RADIOBUTTON
            # tracker
            self.radioButton_hide_create.toggled.connect(self.hide_create)
            # scenario
            self.radioButton_tags_notes.toggled.connect(self.hide_chapter)
            # generate store
            self.radioButton_options_store.toggled.connect(self.options_generate_store)

            # COMBOBOX
            # rules
            self.comboBox_rules.currentTextChanged.connect(self.changed_combobox_rules)
            # generate store
            self.box_choose_shop.currentTextChanged.connect(self.view_store)
            # generate npc
            self.box_generate_npc.currentTextChanged.connect(self.view_npc)
            self.comboBox_choose_chapter.currentTextChanged.connect(self.view_text_chapter)

            # LISTWIDGET
            # scenario
            self.list_tags.clicked.connect(self.set_current_index)
            # music
            self.listWidget_category.currentRowChanged.connect(self.listView_scene_update)
            self.listWidget_music.doubleClicked.connect(self.play_local_music)
            # viewer
            self.listWidget_img.doubleClicked.connect(self.open_current_img)

            # SPINBOX
            # img viewer
            self.spinBox_enemy_token.valueChanged.connect(self.spinBox_chek_enemy)
            self.spinBox_hero_token.valueChanged.connect(self.spinBox_chek_hero)

            # TEXTEDIT
            # tracker
            # scenario
            self.text_scenario.textChanged.connect(self.set_text_to_scenario)
            self.text_chapter.textChanged.connect(self.set_text_chapter)
            # note
            self.text_notes.textChanged.connect(self.shop_notes_edit)
            self.note_edit_0.textChanged.connect(self.save_text)
            self.note_edit_1.textChanged.connect(self.save_text)
            self.note_edit_2.textChanged.connect(self.save_text)
            self.note_edit_3.textChanged.connect(self.save_text)
            # generate store
            self.search_assortment_edit.textChanged.connect(self.search_for_assortment_store)
            # generate npc
            self.text_generate_npc.textChanged.connect(self.npc_notes_edit)

            # hotkeys
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+L"), self, self.lock_window)
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+0"), self, self.lock_window)
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+I"), self, self.open_initiative)
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+V"), self, self.open_viewer_window)
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+left"), self, self.left_img)
            QtGui.QShortcut(QtGui.QKeySequence("CTRL+right"), self, self.right_img)

            # method
            self.mixer.set_volume(1)
            self.set_combobox_class()
            self.set_combobox_rules()
            self.add_to_tracker()
            self.store_type_and_qualification_vendor()
            self.options_store_box_update()
            self.npc_box_update()
            self.check_folders()
            self.collect_img()
            self.collect_music()
            self.init_scene()
            self.add_spell_zone()
            self.add_context_menu_listWidget_items_scene()

        @logger.catch
        def close_all_window(self, bool_val=False):
            try:
                if self.initiative_window:
                    self.initiative_window.close()
            except AttributeError:
                pass
            try:
                if self.viewer_window:
                    self.viewer_window.close()
            except AttributeError:
                pass
            try:
                if self.viewer_window_master:
                    self.viewer_window_master.close()
            except AttributeError:
                pass
            try:
                if self.generators_window:
                    self.generators_window.close()
            except AttributeError:
                pass
            try:
                if self.Dialog_add_scene_item:
                    self.Dialog_add_scene_item.close()
            except AttributeError:
                pass
            self.close()

        @logger.catch
        def check_folders(self):
            if not os.path.exists(os.getcwd() + "\music"):
                os.mkdir(os.getcwd() + "\music")

            if not os.path.exists(os.getcwd() + "\images"):
                os.mkdir(os.getcwd() + "\images")

        @logger.catch()
        def user_error(self, text: str, informative_text: str, detailed_text: str):
            error = QMessageBox()
            error.setWindowTitle('Ошибка')
            error.setText(text)
            error.setIcon(QMessageBox.Icon.Warning)
            error.setStandardButtons(QMessageBox.StandardButton.Ok)
            error.setDefaultButton(QMessageBox.StandardButton.Ok)
            error.setInformativeText(informative_text)
            error.setDetailedText(detailed_text)

            error.buttonClicked.connect(self.popup_action)

            error.exec()
        '''
        Menu
        '''

        @logger.catch
        def main_menu(self, bool_val):
            menu = QMenu()
            menu.setStyleSheet("QMenu    {background-color: rgb(55, 55, 55);\n"
                                       "    color: rgb(247, 147, 30);}\n"
                               "QMenu::item {background-color: transparent;}\n"
                               "QMenu::item:selected {background-color: rgb(85, 85, 85);}")
            action_save = menu.addAction("Save", self.actions_save)
            icon_save = QtGui.QIcon()
            icon_save.addPixmap(QtGui.QPixmap("img/icon/save.ico"), QtGui.QIcon.Mode.Normal,
                                QtGui.QIcon.State.Off)
            action_save.setIcon(icon_save)

            action_load = menu.addAction("Load", self.action_open)
            icon_load = QtGui.QIcon()
            icon_load.addPixmap(QtGui.QPixmap("img/icon/load.ico"), QtGui.QIcon.Mode.Normal,
                                QtGui.QIcon.State.Off)
            action_load.setIcon(icon_load)

            action_last_session = menu.addAction("Last session", self.last_session)
            action_last_session.setIcon(icon_load)

            action_load_lss_hero = menu.addAction("Load LSS hero", self.create_lss_hero)
            action_load_lss_hero.setIcon(icon_load)

            action_generators = menu.addAction("Generators", self.open_generators)
            icon_generators = QtGui.QIcon()
            icon_generators.addPixmap(QtGui.QPixmap("img/icon/dice.ico"), QtGui.QIcon.Mode.Normal,
                                QtGui.QIcon.State.Off)
            action_generators.setIcon(icon_generators)

            action_info = menu.addAction("Info", self.open_info)
            icon_info = QtGui.QIcon()
            icon_info.addPixmap(QtGui.QPixmap("img/icon/!.png"), QtGui.QIcon.Mode.Normal,
                                      QtGui.QIcon.State.Off)
            action_info.setIcon(icon_info)


            menu.exec(self.pos())

        @logger.catch
        def actions_save(self):
            '''
            DOCKSTRING: сохранение в json файл
            '''
            hero_dict = []
            for i in hero.values():
                hero_dict.append(i.get_save_stats())

            global note_zero
            global note_one
            global note_two
            global note_three
            note_zero = self.note_edit_0.toPlainText()
            note_one = self.note_edit_1.toPlainText()
            note_two = self.note_edit_2.toPlainText()
            note_three = self.note_edit_3.toPlainText()

            save_dict = (
                hero_dict,
                music,
                note_zero,
                note_one,
                note_two,
                note_three,
                store,
                npc,
                dict_preset,
                scenario,
                scenario_text,
                scenario_chapter,
            )
            data = QFileDialog.getSaveFileName(self, filter="Save (*.json)")[0]

            try:
                with open(data, 'w') as outfile:
                    json.dump(save_dict, outfile)
            except FileNotFoundError:
                logger.info("action_save. except")

        @logger.catch
        def action_open(self):
            '''
            DOCKSTRING: загрузка из json файла
            '''
            global dict_preset

            data = QFileDialog.getOpenFileName(self, filter="Save (*.json)")[0]

            try:
                with open(data, 'r', encoding="utf-8") as json_file:
                    data = json.load(json_file)
                    global hero
                    global music
                    global store
                    global npc
                    global scenario
                    global scenario_text
                    global scenario_chapter
                    self.load_hero(data[0])
                    music = data[1]
                    self.note_edit_0.setText(data[2])
                    self.note_edit_1.setText(data[3])
                    self.note_edit_2.setText(data[4])
                    self.note_edit_3.setText(data[5])
                    store = data[6]
                    npc = data[7]
                    dict_preset = data[8]
                    scenario = data[9]
                    scenario_text = data[10]
                    scenario_chapter = data[11]

                self.music_changer_listview_category_update()
                self.add_to_del_char_box()
                self.box_choose_shop_update()
                self.box_generate_npc_update()
                self.comboBox_choose_chapter_update()
                self.update_list_tags()
                self.initiative_window.enemy_dict_preset = dict_preset
            except FileNotFoundError:
                logger.info("action_open. except")

        @logger.catch
        def last_session(self):
            '''
            DOCKSTRING: загрузка из json файла
            '''
            global dict_preset

            try:
                with open('last_session.json', 'r', encoding="utf-8") as json_file:
                    data = json.load(json_file)
                    global hero
                    global music
                    global store
                    global npc
                    global scenario
                    global scenario_text
                    global scenario_chapter
                    self.load_hero(data[0])
                    music = data[1]
                    self.note_edit_0.setText(data[2])
                    self.note_edit_1.setText(data[3])
                    self.note_edit_2.setText(data[4])
                    self.note_edit_3.setText(data[5])
                    store = data[6]
                    npc = data[7]
                    dict_preset = data[8]
                    scenario = data[9]
                    scenario_text = data[10]
                    scenario_chapter = data[11]

                self.music_changer_listview_category_update()
                self.add_to_del_char_box()
                self.box_choose_shop_update()
                self.box_generate_npc_update()
                self.comboBox_choose_chapter_update()
                self.update_list_tags()
                self.initiative_window.enemy_dict_preset = dict_preset
            except FileNotFoundError:
                self.user_error('Последняя сессия не обнаружена', "", "")
                logger.info("last_session. except")

        @logger.catch
        def open_generators(self):
            self.generators_window = MainWindow_too_many_generators()
            self.generators_window.show()

        @logger.catch
        def slide_menu(self, bool_val):
            if self.slide_menu_num == 0:
                self.animation1 = QtCore.QPropertyAnimation(self.frame_menu, b"maximumWidth")
                self.animation1.setDuration(500)
                self.animation1.setStartValue(41)
                self.animation1.setEndValue(150)
                self.animation1.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                self.animation1.start()

                self.animation2 = QtCore.QPropertyAnimation(self.frame_menu, b"minimumWidth")
                self.animation2.setDuration(500)
                self.animation2.setStartValue(41)
                self.animation2.setEndValue(150)
                self.animation2.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                self.animation2.start()

                self.slide_menu_num = 1

            else:
                self.animation1 = QtCore.QPropertyAnimation(self.frame_menu, b"maximumWidth")
                self.animation1.setDuration(500)
                self.animation1.setStartValue(150)
                self.animation1.setEndValue(41)
                self.animation1.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                self.animation1.start()

                self.animation2 = QtCore.QPropertyAnimation(self.frame_menu, b"minimumWidth")
                self.animation2.setDuration(500)
                self.animation2.setStartValue(150)
                self.animation2.setEndValue(41)
                self.animation2.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                self.animation2.start()

                self.slide_menu_num = 0

        @logger.catch
        def slide_menu_hide(self, event):
            if event.button() == Qt.MouseButton.LeftButton:
                if self.slide_menu_num == 1:
                    self.animation1 = QtCore.QPropertyAnimation(self.frame_menu, b"maximumWidth")
                    self.animation1.setDuration(500)
                    self.animation1.setStartValue(150)
                    self.animation1.setEndValue(41)
                    self.animation1.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                    self.animation1.start()
                    self.animation2 = QtCore.QPropertyAnimation(self.frame_menu, b"minimumWidth")
                    self.animation2.setDuration(500)
                    self.animation2.setStartValue(150)
                    self.animation2.setEndValue(41)
                    self.animation2.setEasingCurve(QtCore.QEasingCurve.Type.InOutQuart)
                    self.animation2.start()

                    self.slide_menu_num = 0

        @logger.catch
        def show_frame_menu(self, bool_val=False):
            button = QApplication.instance().sender().text()
            self.info.hide()
            for i in self.menu_frame.keys():
                if i == button:
                    self.menu_frame[i].show()
                else:
                    self.menu_frame[i].hide()
            self.change_icon(button)

        @logger.catch
        def change_icon(self, button: str):
            for i in self.toolButton_dict.keys():
                if i == button:
                    self.toolButton_dict[i].setIcon(self.toolButton_hover_icon[i])
                    self.toolButton_dict[i].setIconSize(QtCore.QSize(23, 23))
                else:
                    if i == "    IMAGE VIEW":
                        self.toolButton_dict[i].setIcon(self.toolButton_icon[i])
                        self.toolButton_dict[i].setIconSize(QtCore.QSize(18, 19))
                    else:
                        self.toolButton_dict[i].setIcon(self.toolButton_icon[i])
                        self.toolButton_dict[i].setIconSize(QtCore.QSize(20, 20))

        @logger.catch
        def open_info(self):
            self.frame_tracker.hide()
            self.frame_scenario.hide()
            self.frame_notes.hide()
            self.frame_music_changer.hide()
            self.frame_rules.hide()
            self.frame_generate_store.hide()
            self.frame_npc_generator.hide()
            self.info.show()
            self.frame_viewer.hide()

        @logger.catch
        def lock_window(self, bool_val=False):
            self.frame_tracker.hide()
            self.frame_scenario.hide()
            self.frame_notes.hide()
            self.frame_music_changer.hide()
            self.frame_rules.hide()
            self.frame_generate_store.hide()
            self.frame_npc_generator.hide()
            self.info.hide()
            self.frame_viewer.hide()

            self.toolButton_tracker.setIcon(self.tracker_icon)
            self.toolButton_tracker.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_scenario.setIcon(self.scenario_icon)
            self.toolButton_scenario.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_notes.setIcon(self.notes_icon)
            self.toolButton_notes.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_rules.setIcon(self.options_icon)
            self.toolButton_rules.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_generate_store.setIcon(self.dice_icon)
            self.toolButton_generate_store.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_npc_generator.setIcon(self.dice_icon)
            self.toolButton_npc_generator.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_music_changer.setIcon(self.music_icon)
            self.toolButton_music_changer.setIconSize(QtCore.QSize(20, 20))
            self.toolButton_img_view.setIcon(self.img_icon)
            self.toolButton_img_view.setIconSize(QtCore.QSize(18, 19))



        '''
        Main window hide
        '''

        @logger.catch
        def set_combobox_class(self):
            for i in PLAYER_CLASS:
                self.comboBox_hero_class.addItem(i)

        @logger.catch
        def input_chek(self, bool_val):
            '''
            DOCKSTRING: Проверка чисел
            '''
            try:
                hp_check = int(self.hp_edit.text())
                ac_check = int(self.ac_edit.text())
                initiative_check = int(self.initiative_edit.text())

                self.create_hero()
            except ValueError:
                self.user_error('Не корректный ввод!',
                                "",
                                'HP, AC, Initiative должны состоять только из цифр')
                logger.info("input_chek. except")

        @logger.catch
        def create_hero(self):
            '''
            DOCKSTRING: Создание персонажа в редакторе и добавление его в словарь
            '''
            if self.name_edit.text() not in hero.keys():
                if len(hero) <= 7:
                    hero.update({self.name_edit.text(): Hero(self.centralwidget, self.name_edit.text(),
                                                             self.hp_edit.text(), self.ac_edit.text(),
                                                             self.initiative_edit.text(), "",
                                                             self.comboBox_hero_class.currentText())})
                else:
                    self.user_error("Максимум персонажей", "", "Максимум персонажей 8")
            else:
                self.user_error("Имя занято", "", "Персонаж с таким именем уже существует.")

            self.add_to_del_char_box()
            self.add_to_tracker()

        @logger.catch
        def create_lss_hero(self):
            file = QFileDialog.getOpenFileName(self, filter="Hero (*.json)")[0]
            with open(file, "r", encoding="utf-8") as file:
                json_hero = json.load(file)
            if json_hero.get("jsonType") == "character":
                hero.update({json_hero.get('name').get('value'): Hero(self.centralwidget, "", 0, 0, 0, "", "",
                                                                      lss_json=json_hero)})
            self.add_to_del_char_box()
            self.add_to_tracker()

        @logger.catch
        def load_hero(self, data):
            for i in data:
                hero.update({i[0]: Hero(self.centralwidget, i[0], i[1], i[2], i[3], i[4], i[5], current_hp=i[6])})
            self.add_to_tracker()

        @logger.catch
        def hide_create(self, check_radiobutton):
            '''
            DOCKSTRING: круглая кнопка. Скрыть или показать редактор персонажа
            '''
            if check_radiobutton is True:
                self.frame_create.hide()
                self.frame_tools.show()
            else:
                self.frame_create.show()
                self.frame_tools.hide()


        '''
        Main window show
        '''

        @logger.catch

        @logger.catch
        def open_initiative(self, bool_val=False):
            self.initiative_window.show()
            self.app_func_initiative_window()


        @logger.catch
        def app_func_initiative_window(self):
            #chekClose
            self.initiative_window.windowClose.connect(self.set_stat_after_fight)
            #Label
            self.initiative_window.hero = hero
            self.initiative_window.add_player_dice()
            #method
            self.initiative_window.view_enemy_preset()
            #connect
            self.initiative_window.del_enemy_signal.connect(self.update_initiative)

        @logger.catch
        def set_stat_after_fight(self):
            for i in hero:
                for item in self.initiative_window.initiative_list:
                    if item[1] == i:
                        hero[i].current_hp = item[2]
                        hero[i]._set_hp()
            self.save_dict_preset()

        def save_dict_preset(self):
            global dict_preset
            dict_preset = self.initiative_window.enemy_dict_preset

        @logger.catch
        def roll_dice(self, bool_val):
            '''
            DOCKSTRING: рандом кубика(числа) и вывод в окно
            '''
            check_advantage = self.check_advantage.isChecked()
            try:
                dice = int(self.dice_edit.text())
                amount = int(self.amount_dice_box.text())
                modifier = int(self.modifier_box.text())
                value = 0
                for roll in range(amount):
                    value += random.randint(1, dice) + modifier
                if check_advantage is False:
                    self.label_roll_dice.setText(str(value))
                else:
                    value_advantege = 0
                    for roll in range(amount):
                        value_advantege += random.randint(1, dice) + modifier
                    self.label_roll_dice.setText(str(value) + ' ' + str(value_advantege))

            except ValueError:
                self.user_error('Не корректный ввод данных', "", "")
                logger.info("roll_dice. except")

        @logger.catch
        def add_to_del_char_box(self):
            self.comboBox_del_char.clear()
            for i in hero.values():
                self.comboBox_del_char.addItem(str(i))

        @logger.catch
        def del_char(self, bool_val):
            try:
                deleted = ""
                for i in hero.values():
                    if self.comboBox_del_char.currentText() == str(i):
                        self.gridLayout_characters.removeWidget(i.get_frame())
                        i.get_frame().deleteLater()
                        deleted = str(i)
                hero.pop(deleted)

                self.comboBox_del_char.removeItem(self.comboBox_del_char.currentIndex())

            except KeyError:
                self.user_error('Поле пустое, либо этого персонажа уже нет!', "", "")
                logger.info(f"del_char. except")

        @logger.catch
        def add_to_tracker(self):
            '''
            DOCKSTRING: добавление созданных персонажей в трекер
            '''
            counter_vertical = 1
            counter_horizontal = 0
            hight_frame = 160
            for i in hero.values():
                if counter_horizontal == 4:
                    counter_horizontal = 0
                    counter_vertical += 1
                self.gridLayout_characters.addWidget(i.get_frame(), counter_vertical, counter_horizontal, 1, 1)
                counter_horizontal += 1

        @logger.catch
        def popup_action(self, but):
            '''
            DOCKSTRING: Заглушка для ошибок
            '''
            if but.text() == 'Ok':
                logger.info("popup_action")

        '''
        Scenario
        '''

        @logger.catch
        def del_chapter(self, bool_val):
            global scenario_chapter
            try:
                scenario_chapter.pop(self.comboBox_choose_chapter.currentText())
                self.comboBox_choose_chapter_update()
            except KeyError:
                self.user_error('Объект для удаления не найден', "", "")
                logger.info("del_chapter. except")

        @logger.catch
        def hide_chapter(self, radioButton_tags_notes):
            '''
            DOCKSTRING: Скрытие основного окна сценария и вывод тэгов
            '''
            if radioButton_tags_notes:
                self.pushButton_add_tags.show()
                self.pushButton_del_tags.show()
                self.list_tags.show()
                self.text_scenario.show()

                self.comboBox_choose_chapter.hide()
                self.text_chapter.hide()
                self.edit_add_chapter.hide()
                self.pushButton_add_chapter.hide()
                self.pushButton_del_chapter.hide()
            else:
                self.comboBox_choose_chapter.show()
                self.text_chapter.show()
                self.edit_add_chapter.show()
                self.pushButton_add_chapter.show()
                self.pushButton_del_chapter.show()

                self.pushButton_add_tags.hide()
                self.pushButton_del_tags.hide()
                self.list_tags.hide()
                self.text_scenario.hide()


        @logger.catch
        def add_chapter(self, bool_val):
            global scenario_chapter
            if self.edit_add_chapter.text() in scenario_chapter.keys():
                self.user_error('Такая глава уже есть', "", "")
            else:
                if self.edit_add_chapter.text() != "":
                    scenario_chapter[self.edit_add_chapter.text()] = ''
                self.comboBox_choose_chapter_update()

        @logger.catch
        def comboBox_choose_chapter_update(self):
            self.comboBox_choose_chapter.clear()

            for i in scenario_chapter.keys():
                self.comboBox_choose_chapter.addItem(i)
            self.comboBox_choose_chapter.setCurrentIndex(len(scenario_chapter)-1)

        @logger.catch
        def view_text_chapter(self, bool_val):
            try:
                self.text_chapter.setText(scenario_chapter[self.comboBox_choose_chapter.currentText()])
            except KeyError as er:
                logger.info(f"view_text_chapter. except KeyError {er}")
                pass

        @logger.catch
        def set_text_chapter(self):
            scenario_chapter[self.comboBox_choose_chapter.currentText()] = self.text_chapter.toPlainText()

        @logger.catch
        def status_list_tags(self, bool_val):
            if self.status == 0:
                self.add_scenario_category()
            else:
                self.add_scenario_object()

        @logger.catch
        def del_object_scenario(self, bool_val):
            global scenario
            global scenario_text
            try:
                if self.list_tags.currentItem():
                    scenario[self.current_index.row()][1].pop(self.list_tags.currentRow() - 1)
                    scenario_text.pop(self.list_tags.currentItem().text())
                    self.update_list_tags_object()
            except AttributeError:
                self.user_error('Выберите объект для удаления', "", "")
                logger.info("del_object_scenario. except AttributeError")

        @logger.catch
        def add_scenario_category(self):
            global scenario
            text, val = QInputDialog.getText(self, "Enter", "Add category")
            if text != "":
                scenario.append([text, []])
                self.update_list_tags()

        @logger.catch
        def add_scenario_object(self):
            global scenario
            global scenario_text
            text, val = QInputDialog.getText(self, "Enter", "Add notes")
            if text != "":
                scenario[self.current_index.row()][-1].append(text)
                scenario_text[text] = ""
                self.update_list_tags_object()

        @logger.catch
        def update_list_tags(self):
            self.list_tags.clear()
            self.status = 0

            for i in scenario:
                self.list_tags.addItem(i[0])

        @logger.catch
        def set_current_index(self, value):
            if self.status == 0 or self.list_tags.currentItem().text() == "...":
                self.current_index = self.list_tags.currentIndex()
                self.back_category_list_tags()
            else:
                if self.list_tags.currentItem().text() in scenario_text.keys():
                    self.text_scenario.setText(scenario_text[self.list_tags.currentItem().text()])

        @logger.catch
        def back_category_list_tags(self):
            if self.list_tags.currentItem().text() == "...":
                self.update_list_tags()
            else:
                self.update_list_tags_object()

        @logger.catch
        def update_list_tags_object(self):
            self.list_tags.clear()
            self.status = 1
            self.list_tags.addItem("...")
            if scenario[self.current_index.row()][1]:
                for i in scenario[self.current_index.row()][1]:
                    self.list_tags.addItem(i)
            else:
                pass

        @logger.catch
        def set_text_to_scenario(self):
            if self.list_tags.currentItem():
                if self.list_tags.currentItem().text() in scenario_text.keys():
                    scenario_text[self.list_tags.currentItem().text()] = self.text_scenario.toPlainText()
                else:
                    pass

        '''
        Notes
        '''

        @logger.catch
        def save_text(self):
            global note_zero
            global note_one
            global note_two
            global note_three
            global note_char_zero
            global note_char_one
            global note_char_two
            global note_char_three
            note_zero = self.note_edit_0.toPlainText()
            note_one = self.note_edit_1.toPlainText()
            note_two = self.note_edit_2.toPlainText()
            note_three = self.note_edit_3.toPlainText()

        '''
        Music changer
        '''

        @logger.catch
        def music_changer_update(self, bool_val):
            '''
            DOCKSTRING: Добавление ссылок на музыку в словарь в формате сцена: урл
            '''
            if self.category_edit.text() and self.scene_edit.text() != "":
                if self.category_edit.text() in music.keys():
                    if self.scene_edit.text() in music[self.category_edit.text()].keys():
                        item = music[self.category_edit.text()][self.scene_edit.text()].split(' ')
                        if self.url_edit.text() in item:
                            self.user_error('Такая ссылка уже есть в этой сцене', "", "")
                        else:
                            music[self.category_edit.text()][self.scene_edit.text()] += ' ' + self.url_edit.text()
                    else:
                        music[self.category_edit.text()][self.scene_edit.text()] = self.url_edit.text()
                else:
                    music[self.category_edit.text()] = {self.scene_edit.text(): self.url_edit.text()}
                self.listWidget_scene.clear()
                self.music_changer_listview_category_update()


        @logger.catch
        def music_changer_listview_category_update(self):
            '''
            DOCKSTRING: обновление комбо бокса, при загрузке сохранения
            '''
            self.listWidget_category.clear()
            for i in music.keys():
                self.listWidget_category.addItem(i)

        @logger.catch
        def listView_scene_update(self, val=0):
            self.listWidget_scene.clear()
            current_index = self.listWidget_category.currentRow()
            list_music = list(music.keys())
            for i in music[list_music[current_index]].keys():
                self.listWidget_scene.addItem(i)

        @logger.catch
        def music_changer_play(self, bool_val):
            num_one = self.listWidget_category.currentRow()
            num_two = self.listWidget_scene.currentRow()
            if num_one != -1:
                list_music = list(music.keys())
                list_music_deep = list(music[list_music[num_one]])
                value = music[list_music[num_one]][list_music_deep[num_two]].split(' ')
                for i in enumerate(value):
                    webbrowser.open(value[i[0]])
                    time.sleep(1)

        @logger.catch
        def music_changer_delete(self, bool_val):
            num_one = self.listWidget_category.currentRow()
            num_two = self.listWidget_scene.currentRow()
            if num_one != -1:
                list_music = list(music.keys())
                if num_two == -1:
                    if len(list(music.keys())) == 1:
                        error = QMessageBox()
                        self.user_error('На данный момент нельзя удалить последнюю категорию', "", "")
                    else:
                        music.pop(list_music[num_one])
                        self.music_changer_listview_category_update()
                else:
                    list_music_deep = list(music[list_music[num_one]])
                    music[list_music[num_one]].pop(list_music_deep[num_two])
                    self.music_changer_listview_category_update()
                    self.listView_scene_update()

        @logger.catch
        def collect_music(self, bool_val=False):
            '''
            DOCKSTRING: Поиск файлов в папке
            '''
            self.list_song = []
            listOfFiles = os.listdir('./music')
            for entry in listOfFiles:
                if fnmatch.fnmatch(entry, "*.mp3"):
                    self.list_song.append(entry)
            if self.list_song:
                self.update_list_music()

        @logger.catch
        def update_list_music(self):
            self.listWidget_music.clear()
            for i in sorted(self.list_song,
                            key=lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split('(\d+)', s)]):
                self.listWidget_music.addItem(i)
            self.listWidget_music.setCurrentRow(0)

        @logger.catch
        def play_local_music(self, bool_val=False):
            song = str(os.getcwd()) + "/music/" + self.listWidget_music.currentItem().text()
            song_lenght = MP3(song).info.length
            self.mixer.unload()
            self.mixer.load(song)
            self.music_timer.length = int(song_lenght)
            self.horizontalSlider_music.setMaximum(int(song_lenght))
            self.music_timer.start()
            self.mixer.play()

        @logger.catch
        def update_slider_position(self, lenght):
            if not self.mixer.get_busy():
                return

            self.horizontalSlider_music.setValue(int(lenght))

        @logger.catch
        def set_track_position(self, position):
            self.music_timer.counter = position
            self.mixer.set_pos(position)

        @logger.catch
        def stop_local_music(self, bool_val=False):
            if self.mixer.get_busy():
                self.mixer.stop()
                self.music_timer.stop()
                self.music_timer.length = 0
                self.horizontalSlider_music.setValue(0)
                self.mixer.unload()

        @logger.catch
        def pause_local_music(self, bool_val=False):
            if not self.listWidget_music.currentItem().text():
                return

            if not self.mixer.get_busy():
                self.pushButton_music_pause.setText("pause")
                self.music_timer.is_running = True
                self.music_timer.start()
                time.sleep(0.01)
                self.music_timer.counter = self.current_timer
                self.mixer.unpause()


            else:
                self.pushButton_music_pause.setText("unpause")
                self.music_timer.stop()
                self.mixer.pause()
                self.current_timer = self.music_timer.counter

        '''
        Rules
        '''

        @logger.catch
        def set_combobox_rules(self):
            for i in DICT_RULES:
                self.comboBox_rules.addItem(i)

        @logger.catch
        def changed_combobox_rules(self, rules_name):
            self.label_rules.setText(DICT_RULES[rules_name])

        '''
        Img viewer
        '''

        @logger.catch
        def collect_img(self, bool_val=False):
            '''
            DOCKSTRING: Поиск файлов в папке
            '''
            self.list_images = []
            listOfFiles = os.listdir('./images')
            for entry in listOfFiles:
                if fnmatch.fnmatch(entry, "*.png"):
                    self.list_images.append(entry)
            for entry in listOfFiles:
                if fnmatch.fnmatch(entry, "*.jpeg"):
                    self.list_images.append(entry)
            for entry in listOfFiles:
                if fnmatch.fnmatch(entry, "*.jpg"):
                    self.list_images.append(entry)
            for entry in listOfFiles:
                if fnmatch.fnmatch(entry, "*.bmp"):
                    self.list_images.append(entry)
            if self.list_images:
                self.update_list_img()

        @logger.catch
        def update_list_img(self):
            self.listWidget_img.clear()
            for i in sorted(self.list_images,
                            key=lambda s: [int(t) if t.isdigit() else t.lower() for t in re.split('(\d+)', s)]):
                self.listWidget_img.addItem(i)
            self.listWidget_img.setCurrentRow(0)

        @logger.catch
        def open_viewer_window(self, bool_val=False):
            self.viewer_window.show()
            self.viewer_window_master.show()
            self.app_func_viewer_window()
            self.size_token = 100

        @logger.catch
        def app_func_viewer_window(self):
            self.pushButton_open_current.clicked.connect(self.open_current_img)

        @logger.catch
        def left_img(self, bool_val=False):
            if self.listWidget_img.currentRow() != 0:
                self.listWidget_img.setCurrentRow(self.listWidget_img.currentRow() - 1)
                self.open_current_img()

        @logger.catch
        def right_img(self, bool_val=False):
            if self.listWidget_img.currentRow() < len(self.list_images) - 1:
                self.listWidget_img.setCurrentRow(self.listWidget_img.currentRow() + 1)
                self.open_current_img()

        @logger.catch
        def reduce_token(self, bool_val=False):
            for i in self.token_list.values():
                i.reduce_token()

        @logger.catch
        def increase_token(self, bool_val=False):
            for i in self.token_list.values():
                i.increase_token()

        @logger.catch
        def label_scale_img_update(self):
            self.label_scale_img.setText(str(self.scale_img_viewer))

        @logger.catch
        def init_scene(self):
            '''
            DOCKSTRING: Открытие выбранной картинки в окне просмотра
            '''
            try:
                if self.viewer_window and self.viewer_window_master:
                    try:
                        self.scene = QGraphicsScene()
                        self.viewer_window.graphicsView_img.setScene(self.scene)
                        self.viewer_window_master.graphicsView_img.setScene(self.scene)
                        self.viewer_window.graphicsView_img.setSceneRect(0, 0, 1200, 1000)
                        self.viewer_window_master.graphicsView_img.setSceneRect(0, 0, 1200, 1000)
                    except AttributeError:
                        self.user_error('Выберите изображение, из списка', "", "")
                        logger.info("open_current_img, except AttributeError")
            except AttributeError:
                self.user_error('Откройте окно просмотра изображения!', "", "")
                logger.info("open_current_img, open_window except AttributeError")

        @logger.catch
        def open_current_img(self, bool_val=False):
            '''
            DOCKSTRING: Открытие выбранной картинки в окне просмотра
            '''
            self.token_list.clear()
            self.scene_items.clear()
            self.listWidget_items_scene.clear()

            self.scene.clear()
            for i in self.token_list.values():
                self.scene.removeItem(i)
            self.current_img = QPixmap("images/" + self.listWidget_img.currentItem().text()).scaled(
                QtGui.QGuiApplication.primaryScreen().availableGeometry().width(),
                QtGui.QGuiApplication.primaryScreen().availableGeometry().height(),
                aspectRatioMode=Qt.AspectRatioMode.KeepAspectRatio,
                transformMode=Qt.TransformationMode.SmoothTransformation)
            pixmap_item = QGraphicsPixmapItem(self.current_img)
            self.scene.addItem(pixmap_item)

            pixmap_item.setPos(600 - (self.current_img.rect().width() / 2), 0)

            self.add_spell_zone()

        @logger.catch
        def spinBox_chek_enemy(self, bool_val=False):
            '''
            DOCKSTRING: Проверка количества токенов
            '''
            if self.spinBox_enemy_token.value() > 8:
                self.spinBox_enemy_token.setValue(8)
                self.user_error('Максимальное количество противников 8', "", "")

        @logger.catch
        def spinBox_chek_hero(self, bool_val=False):
            '''
            DOCKSTRING: Проверка количества токенов
            '''
            if self.spinBox_hero_token.value() > 8:
                self.spinBox_hero_token.setValue(8)
                self.user_error('Максимальное количество героев 8', "", "")

        @logger.catch
        def add_hero_token(self, bool_val=False):
            if self.viewer_window.isVisible():
                position_token = 50
                token_num = 1

                for i in hero.values():
                    position_token += 100
                    token = TokenImg(150, position_token, self.size_token, str(token_num), "", text=str(i),
                                     player_class=i.get_player_class(), type_token="Hero")
                    token_num += 1
                    if str(i) not in self.token_list:
                        self.token_list.update({str(i): token})
                self.add_token()
            else:
                self.user_error('Откройте окно просмотра изображения!', "", "")

        @logger.catch
        def add_enemy_token(self, bool_val=False):
            if self.viewer_window.isVisible():
                position_token = 50
                token_num = 1

                for i in self.initiative_window.enemy_list:
                    position_token += 100
                    token = TokenImg(50, position_token, self.size_token, str(token_num), i.token, text=i.name, type_token="Enemy")
                    token_num += 1
                    if i not in self.token_list:
                        self.token_list.update({i: token})
                self.add_token()
            else:
                self.user_error('Откройте окно просмотра изображения!', "", "")

        @logger.catch
        def add_unknown_token(self, bool_val=False):
            if self.viewer_window.isVisible():
                position_token = 50
                token_num = 1

                for i in range(int(self.spinBox_enemy_token.text())):
                    position_token += 100
                    token = TokenImg(-35, position_token, self.size_token, str(token_num), "", type_token="Enemy")
                    token_num += 1
                    if f"Enemy_{i}" not in self.token_list:
                        self.token_list.update({f"Enemy_{i}": token})

                position_token = 50
                token_num = 1

                for i in range(int(self.spinBox_hero_token.text())):
                    position_token += 100
                    token = TokenImg(200, position_token, self.size_token, str(token_num), "", type_token="Ally")
                    token_num += 1
                    if f"Ally_{i}" not in self.token_list:
                        self.token_list.update({f"Ally_{i}": token})
                self.add_token()
            else:
                self.user_error('Откройте окно просмотра изображения!', "", "")

        @logger.catch
        def add_initiative(self, bool_val=False):
            if self.initiative_window.initiative_list:
                self.viewer_initiative_list = InitiativeImg(self.initiative_window.initiative_list)
                self.viewer_initiative_list.setPos(-360, 0)
                self.scene.addItem(self.viewer_initiative_list)
            else:
                self.user_error("Нет инициативы", "", "Рассчитайте инициативу в окне инициативы")

        @logger.catch
        def update_initiative(self, list_initiative: list):
            self.viewer_initiative_list.update_initiative(list_initiative)

        @logger.catch
        def add_spell_zone(self):
            self.token_list["token_sphere"] = \
                TokenImg(10, 10, 840, 0, "./img/token/sphere.30feet.png", type_token="Spell_zone sphere")
            self.token_list.get("token_sphere").hide()

            self.token_list["token_cone"] = \
                TokenImg(10, 10, 325, 0, "./img/token/cone.15feet.png", type_token="Spell_zone cone")
            self.token_list.get("token_cone").hide()

            self.token_list["token_square"] = \
                TokenImg(10, 10, 195, 0, "./img/token/square.15feet.png", type_token="Spell_zone square")
            self.token_list.get("token_square").hide()

        @logger.catch
        def add_token(self):
            '''
            DOCKSTRING: Добавление токенов(изображение) в сцену
            '''
            counter = 1
            for i in self.token_list.values():
                if i not in self.scene.items():
                    if "Spell_zone" in i.type_token:
                        self.scene_items[i.type_token] = i

                    elif i.player_class:
                        if f"{i.player_class}_{i.text}_{counter}" in self.scene_items:
                            while f"{i.player_class}_{i.text}_{counter}" in self.scene_items:
                                counter += 1
                            self.scene_items[f"{i.player_class}_{i.text}_{counter}"] = i
                            counter = 1
                        else:
                            self.scene_items[f"{i.player_class}_{i.text}_{counter}"] = i

                    else:
                        if f"{i.type_token}_{i.text}_{counter}" in self.scene_items:
                            while f"{i.type_token}_{i.text}_{counter}" in self.scene_items:
                                counter += 1
                            self.scene_items[f"{i.type_token}_{i.text}_{counter}"] = i
                            counter = 1
                        else:
                            self.scene_items[f"{i.type_token}_{i.text}_{counter}"] = i
                    self.scene.addItem(i)
            self.add_to_scene_items()

        @logger.catch
        def add_context_menu_listWidget_items_scene(self):
            self.listWidget_items_scene_menu = QMenu()
            self.listWidget_items_scene_menu.setStyleSheet("QMenu    {background-color: rgb(55, 55, 55);\n"
                               "    color: rgb(247, 147, 30);}\n"
                               "QMenu::item {background-color: transparent;}\n"
                               "QMenu::item:selected {background-color: rgb(85, 85, 85);}")
            action_hide = self.listWidget_items_scene_menu.addAction("Add", self.add_scene_item_dialog)

            action_show = self.listWidget_items_scene_menu.addAction("Delete", self.del_scene_item)

            action_add = self.listWidget_items_scene_menu.addAction("Hide", self.hide_scene_item)

            action_del = self.listWidget_items_scene_menu.addAction("Show", self.show_scene_item)

            self.listWidget_items_scene.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self.listWidget_items_scene.customContextMenuRequested.connect(self.show_context_menu)

        @logger.catch
        def show_context_menu(self, event):
            self.listWidget_items_scene_menu.exec(QPoint(self.cursor().pos()))

        @logger.catch
        def add_to_scene_items(self):
            self.listWidget_items_scene.clear()
            for i in self.scene_items:
                self.listWidget_items_scene.addItem(i)

        @logger.catch
        def add_scene_item_dialog(self, bool_val=False):
            self.Dialog_add_scene_item = QtWidgets.QDialog()
            self.ui_add_scene_item = Ui_Dialog_new_token()
            self.ui_add_scene_item.setupUi(self.Dialog_add_scene_item)
            self.ui_add_scene_item.pushButton_accept.clicked.connect(self.add_scene_item)
            self.Dialog_add_scene_item.exec()

        @logger.catch
        def add_scene_item(self, bool_val=False):
            if self.ui_add_scene_item.edit_name.text() not in self.token_list:
                token = TokenImg(50, 50, 150, "1", "", text=self.ui_add_scene_item.edit_name.text(), type_token="Hero")
                self.token_list.update({self.ui_add_scene_item.edit_name.text(): token})
                self.Dialog_add_scene_item.accept()
            else:
                self.Dialog_add_scene_item.accept()
                self.user_error("Токен с таким именем уже существует", "", "")

            self.add_token()

        @logger.catch
        def del_scene_item(self, bool_val=False):
            self.scene.removeItem(self.scene_items.get(self.listWidget_items_scene.currentItem().text()))
            self.scene_items.pop(self.listWidget_items_scene.currentItem().text())
            if self.listWidget_items_scene.currentItem().text() in self.token_list:
                self.token_list.pop(self.listWidget_items_scene.currentItem().text())

            self.add_to_scene_items()

        @logger.catch
        def hide_scene_item(self, bool_val=False):
            self.scene_items.get(self.listWidget_items_scene.currentItem().text()).hide()

        @logger.catch
        def show_scene_item(self, bool_val=False):
            self.scene_items.get(self.listWidget_items_scene.currentItem().text()).show()


        '''
        Store
        '''

        @logger.catch
        def del_store(self, bool_val):
            try:
                store.pop(self.box_choose_shop.currentText())
                self.box_choose_shop_update()
            except ValueError:
                self.user_error('Магазин не найден', "", "")
                logger.info("del_store. except ValueError")
            except KeyError:
                self.user_error('Магазин не найден', "", "")
                logger.info("del_store. except KeyError")

        @logger.catch
        def options_store_box_update(self):
            sex = ["Случайно", "Мужчина", "Женщина"]
            age = ["Случайно", "Молодой", "Средний", "Пожилой"]
            random_choice = "Случайно"
            self.box_personality_vendor.addItem(random_choice)
            self.box_look_vendor.addItem(random_choice)
            self.box_voice_vendor.addItem(random_choice)
            for i in sex:
                self.box_sex_vendor.addItem(i)
            for i in age:
                self.box_age_vendor.addItem(i)
            for i in RACE:
                self.box_race_vendor.addItem(i)
            for i in PERSONALITY:
                self.box_personality_vendor.addItem(i)
            for i in LOOK:
                self.box_look_vendor.addItem(i)
            for i in VOICE:
                self.box_voice_vendor.addItem(i)

        @logger.catch
        def options_generate_store(self, radioButton_options_store):
            '''
            DOCKSTRING: Скрытие текстового поля заметок и вывод настроек генератора
            '''
            if radioButton_options_store:
                self.text_notes.hide()

                self.label_store_name_2.show()
                self.edit_store_name_2.show()
                self.label_vendor.show()
                self.label_name_vendor.show()
                self.edit_name_vendor.show()
                self.label_sex_vendor.show()
                self.box_sex_vendor.show()
                self.label_age_vendor.show()
                self.box_age_vendor.show()
                self.label_race_vendor.show()
                self.box_race_vendor.show()
                self.label_personality_vendor.show()
                self.box_personality_vendor.show()
                self.label_look_vendor.show()
                self.box_look_vendor.show()
                self.label_voice_vendor.show()
                self.box_voice_vendor.show()
            else:
                self.text_notes.show()

                self.label_store_name_2.hide()
                self.edit_store_name_2.hide()
                self.label_vendor.hide()
                self.label_name_vendor.hide()
                self.edit_name_vendor.hide()
                self.label_sex_vendor.hide()
                self.box_sex_vendor.hide()
                self.label_age_vendor.hide()
                self.box_age_vendor.hide()
                self.label_race_vendor.hide()
                self.box_race_vendor.hide()
                self.label_personality_vendor.hide()
                self.box_personality_vendor.hide()
                self.label_look_vendor.hide()
                self.box_look_vendor.hide()
                self.label_voice_vendor.hide()
                self.box_voice_vendor.hide()

        @logger.catch
        def store_type_and_qualification_vendor(self):
            for i in MERCHANTS:
                self.box_generate_type.addItem(i)

            for i in QUALIFICATION:
                self.box_generate_cost.addItem(i)

        @logger.catch
        def create_store(self, bool_val):
            sex = sex_npc(self.box_sex_vendor.currentText())
            name = name_npc(sex, self.edit_name_vendor.text())
            if self.edit_store_name_2.text() == "":
                iter_store = 0
                store_name = name_store()
                flag = True
                while flag is True:
                    if store_name in store.keys():
                        store_name = f'store {name}_{str(iter_store)}'
                        iter_store += 1
                    else:
                        flag = False
                store.update({
                    store_name: {
                        'type_store': self.box_generate_type.currentText(),
                        'name_vendor': name,
                        'sex_vendor': sex,
                        'age_vendor': age_npc(self.box_age_vendor.currentText()),
                        'race_vendor': race_npc(self.box_race_vendor.currentText()),
                        'personality_vendor': personality_npc(self.box_personality_vendor.currentText()),
                        'look_vendor': look_npc(self.box_look_vendor.currentText()),
                        'voice_vendor': voice_npc(self.box_voice_vendor.currentText()),
                        'store_value': self.box_generate_cost.currentText(),
                        'vendor_money': money_vendor(self.box_generate_cost.currentText()),
                        'assortment_store': assortment_store(self.box_generate_type.currentText(),
                                                             self.box_generate_cost.currentText()),
                        'text_notes': " "}})
            else:
                iter_store = 0
                store_name = self.edit_store_name_2.text()
                flag = True
                while flag is True:
                    if store_name in store.keys():
                        store_name = f"{self.edit_store_name_2.text()} {str(iter_store)}"
                        iter_store += 1
                    else:
                        flag = False
                store.update({
                    store_name: {
                        'type_store': self.box_generate_type.currentText(),
                        'name_vendor': name,
                        'sex_vendor': sex,
                        'age_vendor': age_npc(self.box_age_vendor.currentText()),
                        'race_vendor': race_npc(self.box_race_vendor.currentText()),
                        'personality_vendor': personality_npc(self.box_personality_vendor.currentText()),
                        'look_vendor': look_npc(self.box_look_vendor.currentText()),
                        'voice_vendor': voice_npc(self.box_voice_vendor.currentText()),
                        'store_value': self.box_generate_cost.currentText(),
                        'vendor_money': money_vendor(self.box_generate_cost.currentText()),
                        'assortment_store': assortment_store(self.box_generate_type.currentText(),
                                                             self.box_generate_cost.currentText()),
                        'text_notes': " "}})
                self.edit_store_name_2.setText("")
            self.edit_name_vendor.setText("")
            self.box_choose_shop_update()

        @logger.catch
        def box_choose_shop_update(self):
            self.box_choose_shop.clear()
            for i in store.keys():
                self.box_choose_shop.addItem(i)
            self.box_choose_shop.setCurrentIndex(len(store.keys())-1)

        @logger.catch
        def view_store(self, store_name):
            if store_name in store.keys():
                text = f"Имя продавца: {store[self.box_choose_shop.currentText()]['name_vendor']}\n" \
                       f"Возраст: {store[self.box_choose_shop.currentText()]['age_vendor']}\n" \
                       f"Пол продавца: {store[self.box_choose_shop.currentText()]['sex_vendor']}\n" \
                       f"Расса продавца: {store[self.box_choose_shop.currentText()]['race_vendor']}\n" \
                       f"Личность продавца: \n{store[self.box_choose_shop.currentText()]['personality_vendor']}\n" \
                       f"Внешность продавца: \n{store[self.box_choose_shop.currentText()]['look_vendor']}\n" \
                       f"Голос продавца: \n{store[self.box_choose_shop.currentText()]['voice_vendor']}\n" \
                       f"Тип лавки: \n{store[self.box_choose_shop.currentText()]['type_store']}\n" \
                       f"Квалификация продавца: {store[self.box_choose_shop.currentText()]['store_value']}\n" \
                       f"Денег у продавца: {store[self.box_choose_shop.currentText()]['vendor_money']}зм"
                self.label_shop_info.setText(text)
                self.text_assortment_shop.setText(f"Ассортимент:\n{store[self.box_choose_shop.currentText()]['assortment_store']}")
                self.text_notes.setText(store[self.box_choose_shop.currentText()]['text_notes'])
            else:
                pass

        @logger.catch
        def search_for_assortment_store(self, bool_val):
            if self.search_assortment_edit.text() == "":
                self.text_assortment_shop.setText(f"Ассортимент:\n{store[self.box_choose_shop.currentText()]['assortment_store']}")
            else:
                message_new = ""
                for i in store[self.box_choose_shop.currentText()]['assortment_store'].split("\n"):
                    if bool_val in i:
                        message_new += i + "\n"
                self.text_assortment_shop.setText(f"Ассортимент:\n{message_new}")

        @logger.catch
        def shop_notes_edit(self):
            if self.box_choose_shop.currentText() != "":
                store[self.box_choose_shop.currentText()]['text_notes'] = self.text_notes.toPlainText()

        '''
        NPC generator
        '''

        @logger.catch
        def del_npc(self, bool_val):
            try:
                npc.pop(self.box_generate_npc.currentText())
                self.box_generate_npc_update()
            except KeyError:
                self.user_error('NPC не найден', "", "")
                logger.info("del_npc, except KeyError")

        @logger.catch
        def npc_box_update(self):
            sex = ["Случайно", "Мужчина", "Женщина"]
            age = ["Случайно", "Молодой", "Средний", "Пожилой"]
            random_choice = "Случайно"
            self.box_personality_npc.addItem(random_choice)
            self.box_look_npc.addItem(random_choice)
            self.box_voice_npc.addItem(random_choice)
            for i in sex:
                self.box_sex_npc.addItem(i)
            for i in age:
                self.box_age_npc.addItem(i)
            for i in RACE:
                self.box_race_npc.addItem(i)
            for i in PERSONALITY:
                self.box_personality_npc.addItem(i)
            for i in LOOK:
                self.box_look_npc.addItem(i)
            for i in VOICE:
                self.box_voice_npc.addItem(i)

        @logger.catch
        def create_npc(self, bool_val):
            npc_sex = sex_npc(self.box_sex_npc.currentText())
            npc_name = name_npc(npc_sex, self.edit_npc_name.text())
            iter_npc = 0
            npc_name_req = npc_name
            flag = True
            while flag is True:
                if npc_name in npc.keys():
                    npc_name = f"{npc_name} {iter_npc}"
                    iter_npc += 1
                else:
                    flag = False
            npc.update({
                npc_name: {
                    'npc_name': npc_name,
                    'npc_sex': npc_sex,
                    'npc_age': age_npc(self.box_race_npc.currentText()),
                    'npc_race': race_npc(self.box_age_npc.currentText()),
                    'npc_personality': personality_npc(self.box_personality_npc.currentText()),
                    'npc_look': look_npc(self.box_look_npc.currentText()),
                    'npc_voice': voice_npc(self.box_voice_npc.currentText()),
                    'text_notes': " "}})
            self.edit_npc_name.setText("")
            self.box_generate_npc_update()

        @logger.catch
        def box_generate_npc_update(self):
            self.box_generate_npc.clear()
            for i in npc.keys():
                self.box_generate_npc.addItem(i)
            self.box_generate_npc.setCurrentIndex(len(npc.keys())-1)

        @logger.catch
        def npc_notes_edit(self):
            if self.box_generate_npc.currentText() != "":
                npc[self.box_generate_npc.currentText()]['text_notes'] = self.text_generate_npc.toPlainText()

        @logger.catch
        def view_npc(self, npc_name):
            if self.box_generate_npc.currentText() != "":
                text = f"Имя: {npc[npc_name]['npc_name']}\n"\
                       f"Возраст: {npc[npc_name]['npc_age']}\n" \
                       f"Пол: {npc[npc_name]['npc_sex']}\n" \
                       f"Расса: {npc[npc_name]['npc_race']}\n"\
                       f"Личность:\n {npc[npc_name]['npc_personality']}\n"\
                       f"Внешность: \n{npc[npc_name]['npc_look']}\n"\
                       f"Голос: \n{npc[npc_name]['npc_voice']}"
                self.label_generate_npc.setText(text)
                self.text_generate_npc.setText(npc[npc_name]['text_notes'])


    if __name__ == "__main__":
        import sys
        app = QtWidgets.QApplication(sys.argv)
        MainWindow = MainWindow()
        MainWindow.show()
        sys.exit(app.exec())

finally:
    hero_dict = []
    for i in hero.values():
        hero_dict.append(i.get_save_stats())

    if hero:
        save_dict = (
            hero_dict,
            music,
            note_zero,
            note_one,
            note_two,
            note_three,
            store,
            npc,
            dict_preset,
            scenario,
            scenario_text,
            scenario_chapter,
        )

        with open("last_session.json", 'w', encoding='utf-8') as outfile:
            json.dump(save_dict, outfile)
    logger.info("End")
